/*
 * -----------------------
 * --- DEVICE HANDLER ----
 * -----------------------
 *
 * STOP:  Do NOT PUBLISH the code to GitHub, it is a VIOLATION of the license terms.
 * You are NOT allowed share, distribute, reuse or publicly host (e.g. GITHUB) the code. Refer to the license details on our website.
 *
 */

/* **DISCLAIMER**
 * THIS SOFTWARE IS PROVIDED "AS IS" AND ANY EXPRESSED OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
 * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 * Without limitation of the foregoing, Contributors/Regents expressly does not warrant that:
 * 1. the software will meet your requirements or expectations;
 * 2. the software or the software content will be free of bugs, errors, viruses or other defects;
 * 3. any results, output, or data provided through or generated by the software will be accurate, up-to-date, complete or reliable;
 * 4. the software will be compatible with third party software;
 * 5. any errors in the software will be corrected.
 * The user assumes all responsibility for selecting the software and for the results obtained from the use of the software. The user shall bear the entire risk as to the quality and the performance of the software.
 */ 
 
def clientVersion() {
    return "01.00.06"
}

/**
 * Heatit Z-Dim Device Handler
 * 
 * Copyright RBoy Apps, reuse or distribution of code is not allowed without permission
 * Change log:
 * 2020-01-30 - (v01.00.06) Disable polling due to hardware load limitations
 * 2019-11-19 - (v01.00.05) Clean up
 * 2019-10-28 - (v01.00.04) Fix for adding device to use in Lightning group and correct preferences text
 * 2019-10-06 - (v01.00.02) Report button details and number correctly
 * 2019-10-02 - (v01.00.01) Report central scenes as button numbers
 * 2019-09-01 - (v01.00.00) Initial public release
 *
 *  Copyright 2017 SmartThings
 *
 *  Licensed under the Apache License, Version 2.0 (the "License"); you may not use this file except
 *  in compliance with the License. You may obtain a copy of the License at:
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 *  Unless required by applicable law or agreed to in writing, software distributed under the License is distributed
 *  on an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the License
 *  for the specific language governing permissions and limitations under the License.
 *
 */

metadata {
	definition (name: "Heatit Z-Dim", namespace: "rboy", author: "RBoy Apps", ocfDeviceType: "oic.d.light") {
		capability "Switch"
        capability "Switch Level"
        capability "Relay Switch"
        capability "Outlet"
		capability "Energy Meter"
		capability "Power Meter"
		capability "Refresh"
		capability "Actuator"
		capability "Sensor"
		capability "Configuration"
        capability "Health Check"
        capability "Button"
        
        attribute "codeVersion", "string"
        attribute "dhName", "string"
        
        command "resetKWH"
        
		fingerprint type: "1101", manufacturer: "019B", prod: "0003", model: "2200", deviceJoinName: "Heatit Z-Dim" // zw:Ls type:1101 mfr:019B prod:0003 model:2200 ver:0.86 zwv:5.03 lib:03 cc:5E,6C,55,98,9F sec:86,85,8E,59,72,5A,73,7A,70,26,25,5B,32 role:05 ff:9CF1 ui:9CF1
	}

	tiles {
		multiAttributeTile(name:"summary", type: "lighting", width: 6, height: 4, canChangeIcon: true){
			tileAttribute ("device.switch", key: "PRIMARY_CONTROL") {
				attributeState "off", label: 'Off', action: "switch.on", icon: "st.switches.switch.off", backgroundColor: "#ffffff", nextState:"..."
				attributeState "on", label: 'On', action: "switch.off", icon: "st.switches.switch.on", backgroundColor: "#00A0DC", nextState:"..."
				attributeState "...", label:'...', icon:"st.switches.switch.on", backgroundColor:"#00A0DC"
			}
            /*tileAttribute ("device.indicatorStatus", key: "SECONDARY_CONTROL") {
                //attributeState "when off", action:"indicator.indicatorWhenOn", icon:"st.indicators.lit-when-off", nextState: "checking"
                attributeState "when on", label: 'LED On', action:"indicator.indicatorNever", nextState: "checking"
                attributeState "never", label: 'LED Off', action:"indicator.indicatorWhenOn", nextState: "checking"
                attributeState "checking", label: '...'
            }*/
            tileAttribute ("device.level", key: "SLIDER_CONTROL") {
                attributeState "level", action:"switch level.setLevel"
            }
            //tileAttribute ("device.color", key: "COLOR_CONTROL") {
            //    attributeState "color", action:"setAdjustedColor"
            //}
        }
		valueTile("power", "device.power", width: 2, height: 2, inactiveLabel: false, decoration: "flat") {
			state "default", label:'${currentValue} W'
		}
        valueTile("energy", "device.energy", width: 2, height: 2, inactiveLabel: false, decoration: "flat") {
			state "default", label:'${currentValue} kWh', action:"resetKWH"
		}
        standardTile("refresh", "device.switch", width: 2, height: 2, inactiveLabel: false, decoration: "flat") {
			state "default", label:'', action:"refresh.refresh", icon:"st.secondary.refresh"
		}

        main "summary"
        details(["summary", "refresh", "energy", "power"])
	}
}

preferences {
    input title: "", description: "Heatit Z-Dim Device Handler v${clientVersion()}", displayDuringSetup: false, type: "paragraph", element: "paragraph"

    input title: "", description: "Leave blank to use default values", displayDuringSetup: false, type: "paragraph", element: "paragraph"
    input "PowerMetering", "number", title: "Load connected (W)", description: "0-200", displayDuringSetup: false, range: "0..200"
    input "MinimumDimLevel", "number", title: "Minimum dim level (%)", description: "1-98", displayDuringSetup: false, range: "1..98"
    input "MaximumDimLevel", "number", title: "Maximum dim level (%)", description: "2-99", displayDuringSetup: false, range: "2..99"
    input "TotalSteps", "number", title: "Number of steps from min to max dim level", description: "5-255", displayDuringSetup: false, range: "5..255"
    input "DimmingDuration", "number", title: "How long it takes to dim (s)", description: "0-127", displayDuringSetup: false, range: "0..127"
    input "RestorePowerLevel", "number", title: "Dimming level after power failure", description: "1-99", displayDuringSetup: false, range: "1..99"
}

/////////////////////////////
// Installation and update //
/////////////////////////////
def installed() {
    log.trace "Installed called: ${device.deviceNetworkId}"
	runIn(0, initialize, [overwrite: true])  // Updated/Installed is called multiple times from the platform
}

def updated() {
    log.trace "Updated called: ${device.deviceNetworkId}"
	runIn(0, initialize, [overwrite: true])  // Updated/Installed is called multiple times from the platform
}

def uninstalled() {
    log.trace "Uninstalled called: ${device.deviceNetworkId}"
}

def initialize() {
	// Device-Watch simply pings if no device events received for 12 hours (checkInterval)
	sendEvent(name: "checkInterval", value: 12 * 60 * 60, displayed: false, data: [protocol: "zwave", hubHardwareId: device.hub.hardwareID, offlinePingable: "1"])
    sendEvent(name: "numberOfButtons", value: 4, descriptionText: "4 supported scene controller buttons") // Initialize default
    sendEvent(name: "supportedButtonValues", value: [ "pushed_2x", "pushed_3x", "pushed_4x", "pushed_5x" ].encodeAsJson(), descriptionText: "4 supported scene controller buttons") // Initialize default
	sendHubCommand(response(configure()).toHubAction())
}

def ping() {
    log.trace "Ping called: ${device.deviceNetworkId}"
	// Just get switch state and there's no need to flood more commands
	sendHubCommand(new physicalgraph.device.HubAction(secure(zwave.switchMultilevelV1.switchMultilevelGet())))
}

// Configuration
private setConfigParameters() {
    def cmds = []

    if (isHeatIt()) {
        cmds += configureHeatIt()
    }

    cmds ? secureSequence(cmds, 1500) : []
}

private configureHeatIt() {
    def cmds = []
    def paramValues = []

    paramValues = [] // Reset it
    ["PowerMetering", "MinimumDimLevel", "MaximumDimLevel", "TotalSteps"].each {
        paramValues += ((settings."$it" == null) ? heatItParamMap."$it".Default : (settings."$it" as Integer)) // Bulk set needs the actual data values, it'll convert to a byte array according to the size specified automatically
    }
    log.debug "Configuring batch settings: ${paramValues}"
    cmds << zwave.configurationV2.configurationBulkSet(handshake: true, numberOfParameters: paramValues.size(), parameterOffset: heatItParamMap.PowerMetering.Param, size: heatItParamMap.PowerMetering.Size, values: paramValues) // Set the parameters in bulk to avoid zwave issues

    // TODO: Once handbrake (bulkReport) starts working, get rid of this individual get calls
    ["PowerMetering", "MinimumDimLevel", "MaximumDimLevel", "TotalSteps"].each {
        cmds << zwave.configurationV2.configurationGet(parameterNumber: heatItParamMap."$it".Param) // Verify after
    }

    ["DimmingDuration", "RestorePowerLevel"].each {
        def paramValue = ((settings."$it" == null) ? heatItParamMap."$it".Default : (settings."$it" as Integer))
        log.debug "Configuring $it: $paramValue"
        cmds << zwave.configurationV2.configurationSet(parameterNumber: heatItParamMap."$it".Param, size: heatItParamMap."$it".Size, configurationValue: getHeatItParamMap(paramValue)."$it".ParamValue)
        cmds << zwave.configurationV2.configurationGet(parameterNumber: heatItParamMap."$it".Param) // Verify after
    }
    
    return cmds
}

def configure() {
    log.trace "Configure called: ${device.deviceNetworkId}"

    runIn(60, refresh) // Give it some time and then run refresh
    
    def cmds = []
    
    //cmds += discoverConfigParameters(), // DEBUGGING

    // Identify and configure the thermostat
    if (!state.MSR) { // If we don't have a MSR, first get it (and wait for it to complete)
        log.debug "Getting Device MSR"
        cmds += [
            zwave.manufacturerSpecificV2.manufacturerSpecificGet().format(),
            zwave.versionV1.versionGet().format(),
        ]
    } else {
        log.trace "Device MSR: $state.MSR"
    }

    cmds = (cmds ? delayBetween(cmds, 1000) + "delay 1000" : []) + setConfigParameters()
    cmds
}

//////////////////////
// Event Generation //
//////////////////////
def parse(String description) {
	//log.trace "${device.deviceNetworkId}: $description"

    sendEvent([name: "codeVersion", value: clientVersion()]) // Save client version for parent app
    sendEvent([name: "dhName", value: "Heatit Z-Dim Device Handler"]) // Save DH Name for parent app

    def result = []
	if (description.startsWith("Err")) {
		result = createEvent(descriptionText:description, isStateChange:true)
	} else if (description != "updated") {
		def cmd = zwave.parse(description, commandClassCapabilities)
		if (cmd) {
			result += zwaveEvent(cmd)
		}
		else {
			log.warn "Unparsed description $description"
		}
	}
    if (result) {
        log.debug result
    }
	result
}

def zwaveEvent(physicalgraph.zwave.commands.securityv1.SecurityMessageEncapsulation cmd) {
    log.warn "SecurityMessageEncapsulation $cmd"
	def encapsulatedCommand = cmd.encapsulatedCommand(commandClassCapabilities)
	if (encapsulatedCommand) {
        state.sec = 1
		zwaveEvent(encapsulatedCommand)
	}
}

def zwaveEvent(physicalgraph.zwave.commands.multichannelv3.MultiChannelCmdEncap cmd) {
	log.warn cmd
	def encapsulatedCommand = cmd.encapsulatedCommand(commandClassCapabilities)
	if (encapsulatedCommand) {
		zwaveEvent(encapsulatedCommand, cmd.sourceEndPoint as Integer)
	} else {
        log.warn "multichannelv3.MultiChannelCmdEncap: unrecognized command $cmd"
    }
}

private secure(physicalgraph.zwave.Command cmd) {
    //log.trace cmd
    //log.trace "Secure: $state.sec"
	if (state.sec) {
		zwave.securityV1.securityMessageEncapsulation().encapsulate(cmd).format()
	} else {
		cmd.format()
	}
}

private secureSequence(commands, delay=300) { // Some of these params need more time to get on this switch or they are dropped
	delayBetween(commands.collect{ secure(it) }, delay)
}

// Multi channel encapsulation of a command with a target endpoint and an optional bitmask addressing
private encap(cmd, ep, bitMask = false) {
    zwave.multiChannelV3.multiChannelCmdEncap(bitAddress: bitMask, destinationEndPoint: ep).encapsulate(cmd)
}

def zwaveEvent(physicalgraph.zwave.commands.meterv3.MeterReport cmd, ep = null) {
    log.trace "$ep: MeterReport: $cmd"
    
    def result = []
    
	if (cmd.scale == 0) {
		result << createEvent(name: "energy", value: (float) (Math.round(cmd.scaledMeterValue * 10.0) / 10.0), unit: "kWh")
	} else if (cmd.scale == 1) {
		result << createEvent(name: "energy", value: (float) (Math.round(cmd.scaledMeterValue * 10.0) / 10.0), unit: "kVAh")
	} else if (cmd.scale == 2) {
		result << createEvent(name: "power", value: (float) (Math.round(cmd.scaledMeterValue * 10.0) / 10.0), unit: "W")
	} else if (cmd.scale == 4) {
		result << createEvent(name: "voltage", value: (float) (Math.round(cmd.scaledMeterValue * 10.0) / 10.0), unit: "V")
	} else if (cmd.scale == 5) {
		result << createEvent(name: "amperage", value: (float) (Math.round(cmd.scaledMeterValue * 10.0) / 10.0), unit: "A")
	} else {
        log.warn "Unknown Meter Report: $cmd"
    }
    
    result
}

def zwaveEvent(physicalgraph.zwave.commands.basicv1.BasicReport cmd, ep = null) {
    log.trace "$ep: $cmd"
    zwaveSwitchEvent(cmd, ep)
}

def zwaveEvent(physicalgraph.zwave.commands.switchbinaryv1.SwitchBinaryReport cmd, ep = null) {
	log.trace "$ep: $cmd"
   	zwaveSwitchEvent(cmd, ep) 
}

def zwaveEvent(physicalgraph.zwave.commands.switchmultilevelv3.SwitchMultilevelReport cmd, ep = null) {
	log.trace "$ep: $cmd"
   	zwaveSwitchEvent(cmd, ep) 
}

private zwaveSwitchEvent(cmd, ep) {
	def result = []
    def switchEvent = createEvent(name: "switch", value: cmd.value ? "on" : "off", descriptionText: "${device.displayName} is ${cmd.value ? "on" : "off"}")
    result << switchEvent
	if (cmd.value) {
		result << createEvent(name: "level", value: cmd.value == 99 ? 100 : cmd.value , unit: "%")
	}
    if (switchEvent.isStateChange) {
		result << response(["delay 3000", zwave.meterV2.meterGet(scale: 2).format()])
	}
    result
}

def zwaveEvent(physicalgraph.zwave.commands.centralscenev1.CentralSceneNotification cmd, ep = null) {
    log.trace "$ep: $cmd"
    
	def result = []
    result = createEvent(name: "button", value: "pushed_${cmd.keyAttributes - 1}x", data: [buttonNumber: 1], descriptionText: "$device.displayName button pressed ${cmd.keyAttributes - 1} times", isStateChange: true)
    
    result
}

def zwaveEvent(physicalgraph.zwave.commands.configurationv2.ConfigurationReport cmd, ep = null) {
    log.trace "$ep: $cmd"
    
    def events = []
    
    if (isHeatIt()) {
        events << processHeatItConfigReport(cmd)
    }
    
    events?.flatten()
}

private processHeatItConfigReport(cmd) {
    //log.trace "Processing HeatIt Config report"

    def result = []
    switch (cmd.parameterNumber) {
        case heatItParamMap.PowerMetering.Param:
            def msg = "Connected load: ${cmd.scaledConfigurationValue}W"
            sendEvent(descriptionText: msg, displayed: false)
            log.info msg
            break            
        case heatItParamMap.MinimumDimLevel.Param:
            def msg = "Minimum dim level: ${cmd.scaledConfigurationValue}%"
            sendEvent(descriptionText: msg, displayed: false)
            log.info msg
            break
        case heatItParamMap.MaximumDimLevel.Param:
            def msg = "Maximum dim level: ${cmd.scaledConfigurationValue}%"
            sendEvent(descriptionText: msg, displayed: false)
            log.info msg
            break
        case heatItParamMap.TotalSteps.Param:
            def msg = "Total steps: ${cmd.scaledConfigurationValue}"
            sendEvent(descriptionText: msg, displayed: false)
            log.info msg
            break
        case heatItParamMap.DoublePressDim.Param:
            def msg = "Double press function: ${cmd.scaledConfigurationValue ? "Dim to highest level" : "Central scene notification"}"
            sendEvent(descriptionText: msg, displayed: false)
            log.info msg
            break
        case heatItParamMap.SceneController.Param:
            def msg = "Scene controller: ${cmd.scaledConfigurationValue ? "Active" : "Disabled"}"
            sendEvent(descriptionText: msg, displayed: false)
            log.info msg
            break
        case heatItParamMap.SwitchOnLevel.Param:
            def msg = "Switch on level: ${cmd.scaledConfigurationValue}%"
            sendEvent(descriptionText: msg, displayed: false)
            log.info msg
            break
        case heatItParamMap.DimmingDuration.Param:
            def msg = "Dimming duration: ${cmd.scaledConfigurationValue}${cmd.scaledConfigurationValue > heatItParamMap.DimmingDuration.Max ? "m" : "s"}"
            sendEvent(descriptionText: msg, displayed: false)
            log.info msg
            break
        case heatItParamMap.MeterReportInterval.Param:
            def msg = "Meter report interval: ${cmd.scaledConfigurationValue}s"
            sendEvent(descriptionText: msg, displayed: false)
            log.info msg
            break
        case heatItParamMap.MeterReportInterval.Param:
            def msg = "Meter report interval: ${cmd.scaledConfigurationValue}s"
            sendEvent(descriptionText: msg, displayed: false)
            log.info msg
            break
        case heatItParamMap.RestorePowerLevel.Param:
            def msg = "Power restore level: ${cmd.scaledConfigurationValue}%"
            sendEvent(descriptionText: msg, displayed: false)
            log.info msg
            break
        default:
            log.warn "Unknown configuration report: $cmd"
	        break
    }
    
    result
}

def zwaveEvent(physicalgraph.zwave.commands.manufacturerspecificv2.ManufacturerSpecificReport cmd, ep = null) {
    log.trace "$ep: $cmd"
	updateDataValue("MSR", String.format("%04X-%04X-%04X", cmd.manufacturerId, cmd.productTypeId, cmd.productId))
	return []
}

def zwaveEvent(physicalgraph.zwave.commands.versionv1.VersionReport cmd, ep = null) {
    log.trace "$ep: $cmd"
	updateDataValue("Ver", cmd.applicationVersion + "." + cmd.applicationSubVersion)
	return []
}

def zwaveEvent(physicalgraph.zwave.Command cmd, ep = null) {
	log.warn "$ep: Unexpected zwave command $cmd"
	return []
}

/////////////////////////////
// Installation and update //
/////////////////////////////
def setLevel(level) {
    log.info "Setting brightness to ${level}%"
    
	if(level > 99) {
        level = 99
    }
    
	secureSequence([
		zwave.basicV1.basicSet(value: level),
		zwave.switchMultilevelV1.switchMultilevelGet()
	], 5000)
}

def on() {
    log.info "Turning device on"

    def cmds = []

    cmds += [
        zwave.basicV1.basicSet(value: 0xFF),
        zwave.switchMultilevelV3.switchMultilevelGet(),
    ]
    
    return secureSequence(cmds, 500)
}

def off() {
    log.info "Turning device off"
    
    def cmds = []

    cmds += [
        zwave.basicV1.basicSet(value: 0x00),
        zwave.switchMultilevelV3.switchMultilevelGet(),
    ]
    
    return secureSequence(cmds, 500)
}

def resetKWH() {
    log.trace "Resetting the KWH"
    
	secureSequence([
		zwave.meterV2.meterReset(),
		zwave.meterV2.meterGet(scale: 0)
	], 500)
}

// Refresh all or a specific endpoint device
def refresh() {
    log.trace "Refresh called\n${zwaveInfo?.inspect()}"

    // For DTH's being upgraded
    if(!device.currentValue("numberOfButtons") || !device.currentValue("supportedButtonValues")) {
        sendEvent(name: "numberOfButtons", value: 4, descriptionText: "4 supported scene controller buttons") // Initialize default
        sendEvent(name: "supportedButtonValues", value: [ "pushed_2x", "pushed_3x", "pushed_4x", "pushed_5x" ].encodeAsJson(), descriptionText: "4 supported scene controller buttons") // Initialize default
    }

    def cmds = []

    cmds += [
        zwave.switchMultilevelV1.switchMultilevelGet(),
        zwave.meterV2.meterGet(scale: 0),
        zwave.meterV2.meterGet(scale: 2),
    ]

    // Identify and configure the thermostat
    if (!state.MSR) { // If we don't have a MSR, first get it (and wait for it to complete)
        log.debug "Getting Device MSR"
        cmds += [
            zwave.manufacturerSpecificV2.manufacturerSpecificGet(),
            zwave.versionV1.versionGet(),
        ]
    } else {
        log.trace "Device MSR: $state.MSR"
    }

    //cmds += zwave.configurationV2.configurationGet(parameterNumber: heatItParamMap.LED.Param)
    
    sendHubCommand(response(secureSequence(cmds, 500)).toHubAction()) // This can be called from a timer function
}

def discoverConfigParameters() {
    log.trace "Discovering the first 15 configuration parameters"

    def cmds = []
    (1..30).each { param ->
        cmds << secure(zwave.configurationV2.configurationGet(parameterNumber: param)) // Check before
    }
    cmds
}

// Checks if it's a HeatIt thermostat
private isHeatIt() {
    (state.MSR?.startsWith("019B") || ("019B" == zwaveInfo?.mfr)) ? true : false // If called from installed(), MSR may not exist yet
}

// Supported command class versions
private getCommandClassCapabilities() {
    [
        0x85: 2, // Association
        0x59: 1, // Association Grp Info
        0x8E: 2, // Multi Channel Association (supports v3)
        0x86: 1, // Version (supports v3)
        0x70: 2, // Configuration (supports v3)
        0x72: 2, // Manufacturer Specific
        0x5A: 1, // Device Reset Locally
        0x73: 1, // Powerlevel
        0x7A: 2, // Firmware Update Md (supports v4)
        0x20: 1, // Basic (supports v2)
        0x25: 1, // Switch Binary
        0x32: 3, // Meter
        0x26: 3, // Multilevel Switch (supports v4)
        0x5B: 1, // Central Scene (supports v3)
        0x98: 1, // Security
        0x55: 1, // Transport Service (supports v2)
    ]
}

private getHeatItParamMap(value = null) {
	[
        "PowerMetering": 		[ Param: 1, Size: 1, Default: 0, Min: 0, Max: 200, Value: reverseValue(value) ].with { put('ParamValue', paramValue(value, get('Size'))); it },
        "MinimumDimLevel": 		[ Param: 2, Size: 1, Default: 20, Min: 1, Max: 98, Value: reverseValue(value) ].with { put('ParamValue', paramValue(value, get('Size'))); it },
        "MaximumDimLevel": 		[ Param: 3, Size: 1, Default: 85, Min: 2, Max: 99, Value: reverseValue(value) ].with { put('ParamValue', paramValue(value, get('Size'))); it },
        "TotalSteps": 			[ Param: 4, Size: 1, Default: 15, Min: 5, Max: 255, Value: reverseValue(value) ].with { put('ParamValue', paramValue(value, get('Size'))); it },
        "DoublePressDim":		[ Param: 5, Size: 1, Default: 1, Enabled: 1, Disabled: 0 ],
        "SceneController":		[ Param: 6, Size: 1, Default: 1, Enabled: 1, Disabled: 0 ],
        "SwitchOnLevel": 		[ Param: 7, Size: 1, Default: 0, Min: 0, Max: 99, Value: reverseValue(value) ].with { put('ParamValue', paramValue(value, get('Size'))); it },
        "DimmingDuration": 		[ Param: 8, Size: 1, Default: 1, Min: 0, Max: 127, Value: reverseValue(value) ].with { put('ParamValue', paramValue(value, get('Size'))); it }, // 128 - 255 are in minutes, we only support seconds for now
        "MeterReportInterval": 	[ Param: 9, Size: 2, Default: 60, Min: 0, Max: 32767, Value: reverseValue(value) ].with { put('ParamValue', paramValue(value, get('Size'))); it },
        "RestorePowerLevel": 	[ Param: 10, Size: 1, Default: 50, Min: 1, Max: 99, Value: reverseValue(value) ].with { put('ParamValue', paramValue(value, get('Size'))); it },
	]
}

private paramValue(value, bytes) {
    if (value == null || !(value instanceof Number)) {
        return null
    }
        
    //log.trace "Param value: $value, $bytes"

    List<Integer> ret = [] // We start with a Integer list and then convert to array (since arrays are fixed in size)
    for (int i=0; i<bytes; i++) {
        ret = [(((value as Long) >> (i*8)) & 0xFF) as Integer] + ret
    }
    
    //log.debug ret as Integer[]
    
    return ret as Integer[] // We need an integer array
}

private reverseValue(value) {
    if (!value || !List.isCase(value)) {
        return null
    }
        
    //log.trace "Reverse value: $value, $bytes"

    Long ret = 0
    for (int i=0; i<value.size(); i++) {
        ret |= ((((value[i] as Integer) & 0xFF) as Long) << ((value.size() - 1 - i) * 8)) as Long
    }
    
    //log.debug ret
    
    return ret
}

// THIS IS THE END OF THE FILE